language: "en-US" # USA English
# Set up means coderabbit should review PRs but only provide one high level walkthrough, collapsed
# It should not state preliminary information like: getting ready to review, draw a picture
# It should not state additional information like: related issues, PRs, suggest reviewers
# It should not continue a casual conversation with users that reply to it

timeout_ms: 900000

# Only documents non-default options:
reviews:
  profile: "assertive" # Assertive profile yields more feedback, that may be considered nitpicky.
  high_level_summary: false # Do not summarise a pull request first as there is a walkthrough
  review_status: false # Do not state what kind of review as performed or why (spammy)
  commit_status: false # Do not state the review is in progress (spammy)
  collapse_walkthrough: true # Provide a walkthrough for reviewers, but collapse it (users shouldn't use this)
  related_issues: false # Do not suggest related issues (spammy)
  related_prs: false # Do not suggest related PRs (spammy)
  suggested_labels: false # Do not suggest labels for the PR (spammy)
  suggested_reviewers: false # Do not suggest reviewers for the PR (spammy)
  in_progress_fortune: false # Do not stall time with a message (spammy)
  poem: false # Do not write a literal poem (spammy)
  enable_prompt_for_ai_agents: false # Disable prompts for AI agents (spammy)
  changed_files_only: true
  consolidate_breaking_changes: true

  path_instructions:
    # --- CUSTOM INSTRUCTIONS FOR EXAMPLES DIRECTORY ---
    - path: "examples/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing SDK examples. Your goal is to ensure examples work verbatim for users who copy-paste them.

        **Priority 1 - Correctness**: 
        - Verify transaction lifecycle chain (construction -> freeze_with -> sign -> execute).
        - Ensure `freeze_with(client)` is called BEFORE signing.
        - Validate that methods referenced actually exist in the `hiero_sdk_python` codebase.
        - Ensure response validation checks `receipt.status` against `ResponseCode` enums (e.g., `ResponseCode.SUCCESS`).

        **Priority 2 - Transaction Lifecycle**: 
        - Check method chaining logic.
        - Verify correct signing order (especially for multi-sig).
        - Ensure explicit `.execute(client)` calls.
        - Verify response property extraction (e.g., using `.token_id`, `.account_id`, `.serial_numbers`).
        - Ensure error handling uses `ResponseCode(receipt.status).name` for clarity.

        **Priority 3 - Naming & Clarity**: 
        - Enforce role-based naming: `operator_id`/`_key`, `treasury_account_id`/`_key`, `receiver_id`/`_key`.
        - Use `_id` suffix for AccountId and `_key` suffix for PrivateKey variables.
        - Validate negative examples explicitly check for failure codes (e.g., `TOKEN_HAS_NO_PAUSE_KEY`).
        - Ensure logical top-to-bottom flow without ambiguity.

        **Priority 4 - Consistency**: 
        - Verify standard patterns: `def main()`, `if __name__ == "__main__":`, `load_dotenv()`.
        - **IMPORT RULES**: 
          1. Accept both top-level imports (e.g., `from hiero_sdk_python import PrivateKey`) and fully qualified imports (e.g., `from hiero_sdk_python.crypto.private_key import PrivateKey`).
          2. STRICTLY validate that the import path actually exists in the project structure. Compare against other files in `/examples` or your knowledge of the SDK file tree.
          3. Flag hallucinations immediately (e.g., `hiero_sdk_python.keys` does not exist).
        - Check for `try-except` blocks with `sys.exit(1)` for critical failures.

        **Priority 5 - User Experience**: 
        - Ensure comments explain SDK usage patterns (for users, not contributors).
        - Avoid nitpicking functional code.
        - Suggest type hints or docstrings only if they significantly improve clarity.

        **Philosophy**: 
        - Examples are copied by users - prioritize explicitness over brevity.
        - Avoid suggestions that `ruff` or linters would catch.
        - Be concise, technical, and opinionated.
        - Flag out-of-scope improvements as potential new issues rather than blocking.

    # --- UNIT TESTS REVIEW INSTRUCTIONS ---
    - path: "tests/unit/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing unit tests for the hiero-sdk-python project.  Your goal is to ensure tests are extensive, deterministic, and protect against breaking changes.

        **CRITICAL PRINCIPLES - Tests Must Fail Loudly & Deterministically**:
        - Tests must provide useful error messages when they fail for future debugging.
        - No `print()` statements - use assertions with descriptive messages.
        - No timing-dependent or unseeded random assertions.
        - No network calls or external dependencies (unit tests are isolated).
        - No unjustified TODOs or skipped tests without tracking issues.

        **PRIORITY 1 - Protect Against Breaking Changes**:
        - Assert public attributes exist (e.g., `assert hasattr(obj, 'account_id')`).
        - Assert return types where relevant (e.g., `assert isinstance(result, AccountId)`).
        - Assert fluent setters return `self` (e.g., `assert tx.set_memo("test") is tx`).
        - Assert backward-compatible defaults are maintained. 
        - If a breaking change is introduced, tests must assert deprecation behavior and test old behavior until removal.

        **PRIORITY 2 - Constructor & Setter Behavior**:
        - Test constructor behavior with valid inputs, edge cases, and invalid inputs.
        - Test setter behavior including method chaining (fluent interface).
        - Verify that setters validate input and raise appropriate exceptions.
        - Test that getters return expected values after construction/setting.

        **PRIORITY 3 - Comprehensive Coverage**: 
        - Unit tests should be extensive - test even if we don't expect users to use it currently.
        - Cover happy paths AND unhappy paths/edge cases.
        - Test boundary conditions, null/None values, empty collections, etc.
        - Avoid brittle ordering assertions unless order is part of the contract. 

        **PRIORITY 4 - No Mocks for Non-Existent Modules**:
        - All imports must reference actual SDK modules - no hallucinated paths.
        - Validate import paths against the actual `src/hiero_sdk_python` structure.
        - Mocks should only be used for external dependencies, not SDK internals.

        **PRIORITY 5 - Test Framework Philosophy**:
        - Prefer repetitive but clear tests over abstracted helper functions.
        - Some core functionality may warrant helper files (considered an exception).
        - Discourage custom helper functions; prefer pytest fixtures when shared setup is needed. 
        - Prefer testing real functionality over mocked behavior.

        **AVOID**:
        - Linter or formatting feedback (leave that to ruff/pre-commit).
        - Nitpicking minor stylistic issues unless they impact maintainability.
        - Overly abstracted test helpers that obscure what's being tested. 

        **PHILOSOPHY**:  
        - Unit tests protect our future selves - be defensive and forward-looking.
        - Tests should be readable by SDK developers:  clear names, brief docstrings, key inline comments.
        - When tests fail, we should immediately know what broke and why.

    # --- INTEGRATION TESTS REVIEW INSTRUCTIONS ---
    - path: "tests/integration/**/*"
      instructions: |
        You are acting as a senior maintainer reviewing integration tests for the hiero-sdk-python project. Your goal is to ensure end-to-end tests validate real network behavior safely and deterministically.

        **CRITICAL PRINCIPLES - Safety & Diagnosability**:
        - **Prioritize safety**: No implicit or default mainnet usage.
        - Secrets and credentials must be injected safely (env vars, not hardcoded).
        - Test failures must be diagnosable with clear error messages.
        - Tests must assert observable network behavior, not just `SUCCESS`.
        - Failure-path tests must assert specific `ResponseCode` values (e.g., `TOKEN_HAS_NO_PAUSE_KEY`).

        **PRIORITY 1 - End-to-End Behavior**:
        - Tests should be end-to-end:  construct ‚Üí freeze ‚Üí sign ‚Üí execute ‚Üí verify.
        - Validate resulting balances, ownership, and state changes (not just transaction success).
        - Assert transaction receipts contain expected data (IDs, serial numbers, etc.).
        - Verify network state after operations (e.g., account balance changed, token transferred).

        **PRIORITY 2 - Test Structure & Maintainability**:
        - One major behavior per test (clear focus).
        - Tests should be readable:  clear names, brief docstrings, key inline comments.
        - Minimal abstraction layers - prefer clarity over DRY.
        - Is the file too monolithic? Flag if tests should be split into smaller modules. 
        - Are helper functions good candidates for pytest fixtures or shared utilities?

        **PRIORITY 3 - Isolation & Cleanup**:
        - Local account creation over operator reuse (avoid state pollution).
        - Are accounts, tokens, and allowances properly cleaned up to avoid state leakage?
        - Recommend teardown strategies or fixture scoping improvements. 
        - Tests should not depend on execution order (avoid brittle assumptions).

        **PRIORITY 4 - Assertions & Coverage**:
        - Do tests validate only success/failure, or also assert resulting state? 
        - Suggest additional assertions that would strengthen correctness (balances, allowances, ownership).
        - Cover happy paths AND unhappy paths (e.g., invalid spender, revoked allowance, insufficient balance).
        - Avoid timing-based or flaky assumptions.

        **PRIORITY 5 - Observability & Debugging**:
        - Could structured logging or transaction metadata improve debugging?
        - Suggest capturing allowance values, transaction IDs, and balances in logs.
        - Ensure error messages provide context for failure diagnosis. 

        **AVOID**:
        - Linter or formatting feedback.
        - Overly abstracted helpers that obscure what's being tested.
        - Timing-dependent assertions (use explicit waits or retries if needed).

        **PHILOSOPHY**: 
        - Integration tests validate real network behavior - they must be reliable and safe.
        - Tests should protect against regressions while being maintainable.
        - When tests fail in CI, developers should immediately understand what broke. 
        - Redundant setup code should be refactored, but clarity trumps abstraction.

    # --- CUSTOM INSTRUCTIONS FOR .GITHUB DIRECTORY ---
    - path: ".github/workflows/**/*"
      instructions: |
        Review workflows as security-sensitive infrastructure.

        A good workflow is small, focused, and boring.
        If a workflow is clever, generic, or overly flexible, it is a risk.

        ---------------------------------------------------------
        PRIORITY 0 ‚Äî ABSOLUTE REQUIREMENTS 
        ---------------------------------------------------------
        - All third-party actions MUST be pinned to full commit SHAs, similar to other workflows.
        - `permissions:` MUST be explicitly declared and minimally scoped.
        - Workflows MUST behave safely when executed from forks.
        - YAML MUST orchestrate steps, not implement business logic.
        - Any workflow that mutates GitHub state MUST support dry-run mode.
        - Dry-run behavior must be explicit and visible in logs.
        - Workflows MUST NOT modify repository source code outside `.github/`.

        ---------------------------------------------------------
        PRIORITY 1 ‚Äî SCOPE, FOCUS & RESTRAINT
        ---------------------------------------------------------
        - The title of each workflow must be relevant, match similar naming schemes, and match its script filename.
        - Each workflow MUST have a single, clearly defined objective and SHOULD document this in a top-level comment.
        - Flag workflows that:
          - Attempt to be generic ‚Äúframeworks‚Äù
          - Include speculative or future-facing logic
          - Perform actions unrelated to the stated goal
        - Over-abstraction and excess flexibility are maintenance risks.

        ---------------------------------------------------------
        PRIORITY 2 ‚Äî INPUT HARDENING
        ---------------------------------------------------------
        - Treat ALL GitHub event data as potentially hostile input, including:
          - issue titles, bodies, and comments
          - labels, usernames, branch names
        - Free-form user input MUST NOT be passed directly into:
          - shell commands
          - gh CLI arguments
          - Node.js exec / spawn calls
        - Require strict allowlists or exact string matches.
        - Flag any use of:
          - eval or bash -c
          - backticks or $(...) with user-controlled input

        ---------------------------------------------------------
        PRIORITY 3 ‚Äî DRY-RUN & SAFE OPERATION
        ---------------------------------------------------------
        - Workflows that mutate state MUST expose:
          workflow_dispatch:
            inputs:
              dry_run:
                default: "true"
        - When dry_run=true, workflows MUST:
          - Log dry mode is active
          - Function on dry run: never post, comment, label, assign or edit
          - Be easy to expand in the future
          - Exit successfully

        ---------------------------------------------------------
        PRIORITY 4 ‚Äî SCRIPT EXTRACTION & CODE TRIM
        ---------------------------------------------------------
        - YAML should orchestrate execution only.
        - All non-trivial logic MUST live in:
          - `.github/scripts/*.sh`
          - `.github/scripts/*.js`
        - Workflow filenames and their primary scripts SHOULD share a clear, matching name.
        - Scripts MUST remain:
          - Purpose-built
          - Trim and readable
          - Easy to maintain
        - Flag:
          - Large `run: |` blocks
          - Inline loops, conditionals, or API calls in YAML
          - Overly generic helper scripts for narrow tasks

        ---------------------------------------------------------
        PRIORITY 5 ‚Äî API EFFICIENCY & DISCIPLINE
        ---------------------------------------------------------
        - GitHub API usage must be intentional and minimal.
        - Prefer:
          - Aggregated queries over per-entity loops
          - Server-side filtering over client-side iteration
          - Reusing data already present in the event payload
        - Pagination MUST:
          - Be considered and justified
          - Enforce hard upper bounds
        - Flag:
          - Repeated API calls inside loops
          - Unbounded pagination
          - Fetching data already available in context

        ---------------------------------------------------------
        PRIORITY 6 ‚Äî CONCURRENCY & IDEMPOTENCY
        ---------------------------------------------------------
        - Workflows that mutate state MUST:
          - Define a deterministic concurrency group
          - Be safe under retries and parallel execution
        - Duplicate prevention is REQUIRED:
          - Marker-based comment detection
          - Check-before-create logic for labels and assignments
        - Assume workflows may:
          - Run multiple times
          - Be retried automatically
          - Execute concurrently with other automations
        - Workflows should avoid logic that duplicates or causes conflicts.

        ---------------------------------------------------------
        PRIORITY 7 ‚Äî PERMISSION CORRECTNESS
        ---------------------------------------------------------
        - Requested permissions MUST exactly match behavior.
        - Explicitly validate common cases:
          - issues: write ‚Üí comments, labels, assignments
          - contents: read ‚Üí repository checkout
          - pull-requests: write ‚Üí PR mutations
        - Flag:
          - Over-permissioned workflows
          - Under-permissioned workflows that would fail at runtime
          - Reliance on default permissions

        ---------------------------------------------------------
        PRIORITY 8 ‚Äî LOGGING & OPERABILITY
        ---------------------------------------------------------
        - Logs should include, where applicable:
          - repository
          - workflow name
          - issue or PR number
          - triggering actor
          - dry-run status
          - decisions made (performed vs skipped)
        - Avoid:
          - Silent success or silent skips
          - Raw payload dumps
          - Any secret or token leakage

    # ============================================================
    # SHELL SCRIPTS
    # ============================================================
    - path: ".github/scripts/**/*.sh"
      instructions: |
        Treat shell scripts as production-grade automation.

        Scripts should be small, focused, and explicit.
        Avoid ‚Äúdo-everything‚Äù or overly generic scripts.

        - MUST use: `set -euo pipefail`
        - MUST validate all required environment variables
        - MUST defensively quote variables
        - MUST validate all untrusted input
        - MUST have bounded loops and pagination
        - MUST support dry-run mode if state is mutated
        - MUST log key decisions and early exits

    # ============================================================
    # JAVASCRIPT SCRIPTS
    # ============================================================
    - path: ".github/scripts/**/*.js"
      instructions: |
        Review JavaScript scripts as long-lived automation code.

        Scripts must remain:
        - Focused
        - Readable
        - Purpose-built

        - All `context.payload` fields MUST be validated
        - Free-form text MUST NOT be trusted
        - Dynamic code execution is prohibited
        - Avoid `child_process.exec`; prefer `execFile` if needed
        - All async operations MUST be wrapped in try/catch
        - Errors MUST include contextual metadata
        - Duplicate API calls MUST be avoided
        - Marker-based deduplication is required
        - Scripts MUST NOT assume write access
        - Permission failures MUST be handled gracefully
    # --- CORE SDK REVIEW ---
    - path: "src/hiero_sdk_python/**/*"
      instructions: |
       You are acting as a senior maintainer reviewing the core sdk logic focus only on core SDK functionality, entities, transactions, queries, client, and utilities.

        **Folder Responsibilities**
        - `account`: account entities and account-related transactions
        - `consensus`: topic entities and consensus-related transactions
        - `contract`: smart contract entities and transactions
        - `file`: file related transaction and entities
        - `query`: all SDK queries, ensure correct return types
        - `client`: network interactions, handling nodes, network and operator
        - `tokens`: token entities and token-related transactions
        - `crypto`: key management (public/private), signatures, verification
        - `schedule`: scheduled transactions handling
        - `nodes`: node-specific transactions and related functionality
        - `transaction`: base transaction class, lifecycle, signing, freezing, execution
        - `system`: system transactions such as freeze
        - `utils`: helper functions and utility modules
        - other modules (`address_book`, `logger`, etc.) ‚Üí SDK infrastructure, logging, or helpers

        **Critical Principles**
        1. **Correctness & Lifecycle**
           - Transactions: construct ‚Üí freeze_with(client) ‚Üí sign ‚Üí execute ‚Üí receipt/response handling
           - Queries: construct ‚Üí execute ‚Üí validate return types
           - Ensure all referenced methods/classes exist in the SDK
           - Exceptions and errors are handled clearly with proper codes/names

        2. **Backward Compatibility**
           - Maintain existing API signatures
           - Avoid breaking changes unless strictly required; flag breaking changes and suggest mitigation
           - Preserve enum values, property names, and method contracts

        3. **Performance & Optimization**
           - Suggest optimizations **only if safe**
           - Avoid unnecessary abstractions or premature refactors
           - Validate multi-sig, batch transactions, and node-specific optimizations

        4. **Consistency & Readability**
           - Naming conventions: `_id` for AccountId, `_key` for PrivateKey, role-based naming
           - Logical file flow, clear docstrings, type hints when beneficial
           - Avoid duplication and enforce folder responsibility boundaries

        5. **Security & Safety**
           - Key handling, signatures, and transaction integrity must be secure
           - Network interactions and gRPC clients must safely handle errors and TLS

        6. **Observability & Error Reporting**
           - Ensure error messages are clear, informative, and deterministic
           - Validate use of response codes (`ResponseCode.SUCCESS`, etc.)
           - Logging and exceptions should give context for debugging

        **Review Output**
        - For each module/folder, provide:
          - ‚úÖ Correctness
          - ‚ö†Ô∏è Backward compatibility risks
          - üí° Optional optimization suggestions
          - General maintainability/readability comments
        - Summarize any major issues, breaking changes, or security risks at the end

chat:
  art: false # Don't draw ASCII art (false)
  auto_reply: false # Don't allow bot to converse (spammy)
